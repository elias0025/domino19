<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dominó Online - Snake Layout</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-color: #2e7d32;
            --table-color: #1b5e20;
            --piece-bg: #fff;
            --dot-color: #000;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* TELA DE LOGIN */
        #login-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            flex-direction: column;
        }

        .card {
            background: #333;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        input {
            padding: 10px;
            margin: 10px 0;
            width: 80%;
            border-radius: 5px;
            border: none;
        }

        button {
            padding: 10px 20px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            margin-top: 10px;
        }

        button:hover { background: #45a049; }
        
        /* ÁREA DO JOGO */
        #game-container {
            display: none;
            flex-direction: column;
            height: 100%;
        }

        #info-bar {
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #board-wrapper {
            flex: 1;
            background-color: var(--table-color);
            overflow: auto; /* Permite rolagem */
            position: relative;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-canvas {
            background-color: transparent;
        }

        #player-hand {
            height: 140px;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            overflow-x: auto;
            padding: 10px;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.3);
        }

        .domino-piece {
            width: 40px;
            height: 80px;
            background: var(--piece-bg);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            transition: transform 0.2s;
            display: flex;
            flex-direction: column;
        }

        .domino-piece:hover { transform: translateY(-10px); }
        .domino-piece.disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .half {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        .half.top { border-bottom: 1px solid #ccc; }

        /* DOTS (Simplificado para CSS) */
        .dot-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 30px; height: 30px;
        }
        .dot { background: black; border-radius: 50%; width: 6px; height: 6px; margin: auto; }

        #status-msg { font-weight: bold; color: yellow; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="login-screen">
        <div class="card">
            <h1>Dominó Multiplayer</h1>
            <p>Insira seu nome para começar</p>
            <input type="text" id="username" placeholder="Seu Nome" maxlength="10">
            <br>
            <div id="initial-actions">
                <button onclick="createRoom()">Criar Sala</button>
            </div>
            <div id="joining-actions" class="hidden">
                <p>Entrando na sala...</p>
                <button onclick="joinRoom()">Entrar Agora</button>
            </div>
            <p id="loading-txt" style="font-size: 0.8em; color: #aaa; margin-top:10px;"></p>
        </div>
    </div>

    <div id="game-container">
        <div id="info-bar">
            <span id="room-info">Sala: ---</span>
            <span id="status-msg">Aguardando jogadores...</span>
            <span id="my-name-display"></span>
        </div>
        
        <div id="board-wrapper">
            <canvas id="game-canvas"></canvas>
        </div>

        <div id="player-hand">
            </div>
    </div>

    <script>
        // CONFIGURAÇÕES GLOBAIS
        const PIECE_W = 40;
        const PIECE_H = 80;
        const GAP = 2;
        
        // ESTADO DO JOGO
        let peer = null;
        let conn = null; // Conexão para clientes
        let connections = []; // Conexões para o Host
        let isHost = false;
        let myName = "";
        let myId = "";
        let roomId = "";
        
        // DADOS DO JOGO
        let gameState = {
            players: [], // {id, name, hand, count}
            board: [],   // {v1, v2, x, y, rot, owner} - Peças na mesa
            turnIndex: 0,
            status: 'waiting', // waiting, playing, ended
            deck: []
        };

        // ELEMENTOS DOM
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const handDiv = document.getElementById('player-hand');
        
        // SETUP INICIAL
        function init() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');

            if (roomParam) {
                roomId = roomParam;
                document.getElementById('initial-actions').classList.add('hidden');
                document.getElementById('joining-actions').classList.remove('hidden');
            }
        }

        // --- LÓGICA DE REDE (PEERJS) ---

        function createRoom() {
            myName = document.getElementById('username').value || "Host";
            if(!myName) return alert("Digite um nome!");

            document.getElementById('loading-txt').innerText = "Gerando sala...";
            
            peer = new Peer(null, { debug: 2 }); // Cria ID aleatório
            
            peer.on('open', (id) => {
                myId = id;
                isHost = true;
                startGameUI(id);
                copyToClipboard(id);
                
                // Adiciona o Host como jogador 0
                gameState.players.push({ id: myId, name: myName, hand: [], count: 0 });
                updateStatus("Aguardando oponentes... (Link copiado!)");
            });

            peer.on('connection', (c) => {
                handleConnection(c);
            });
        }

        function joinRoom() {
            myName = document.getElementById('username').value || "Visitante";
            if(!myName) return alert("Digite um nome!");
            
            peer = new Peer(null, { debug: 2 });

            peer.on('open', (id) => {
                myId = id;
                conn = peer.connect(roomId);
                
                conn.on('open', () => {
                    // Envia nome para o host
                    conn.send({ type: 'JOIN', name: myName });
                    startGameUI(roomId);
                });

                conn.on('data', (data) => {
                    handleClientData(data);
                });
            });
        }

        function handleConnection(c) {
            // Apenas HOST executa isso
            if (gameState.players.length >= 4) {
                c.send({ type: 'ERROR', msg: 'Sala cheia' });
                setTimeout(() => c.close(), 500);
                return;
            }

            c.on('open', () => {
                connections.push(c);
            });

            c.on('data', (data) => {
                if (data.type === 'JOIN') {
                    const newPlayer = { id: c.peer, name: data.name, hand: [], count: 0 };
                    gameState.players.push(newPlayer);
                    broadcastState();
                    
                    // Se tiver pelo menos 2, pode começar (automático aqui para teste, mas ideal seria botão)
                    if (gameState.players.length === 2 && gameState.status === 'waiting') {
                        startMatch();
                    }
                }
                if (data.type === 'MOVE') {
                    processMove(data.piece, data.side, c.peer);
                }
                if (data.type === 'PASS') {
                    nextTurn();
                }
            });
            
            c.on('close', () => {
                // Tratamento simplificado de desconexão
                gameState.players = gameState.players.filter(p => p.id !== c.peer);
                connections = connections.filter(con => con.peer !== c.peer);
                broadcastState();
            });
        }

        function handleClientData(data) {
            if (data.type === 'STATE_UPDATE') {
                gameState = data.state;
                renderBoard();
                renderHand();
                updateInfo();
            }
        }

        function broadcastState() {
            // Envia estado para todos. Oculta as mãos dos outros jogadores por segurança/UI
            connections.forEach(conn => {
                // Cria uma cópia do estado para enviar, filtrando mãos
                const safeState = JSON.parse(JSON.stringify(gameState));
                // O cliente só precisa ver a própria mão
                safeState.players.forEach(p => {
                    if (p.id !== conn.peer) p.hand = []; // Esconde mão dos outros
                });
                conn.send({ type: 'STATE_UPDATE', state: safeState });
            });
            
            // Atualiza a tela do Host também
            renderBoard();
            renderHand();
            updateInfo();
        }

        // --- LÓGICA DO DOMINÓ ---

        function startMatch() {
            gameState.status = 'playing';
            gameState.board = [];
            gameState.deck = generateDeck();
            
            // Distribui 7 peças para cada (ou menos se 4 jogadores)
            const piecesPerPlayer = gameState.players.length === 4 ? 7 : 7;
            
            gameState.players.forEach(p => {
                p.hand = [];
                for(let i=0; i<piecesPerPlayer; i++) {
                    p.hand.push(gameState.deck.pop());
                }
                p.count = p.hand.length;
            });

            // Decide quem começa (quem tem o maior duplo ou maior peça)
            // Simplificado: Jogador 0 começa
            gameState.turnIndex = 0;
            
            broadcastState();
        }

        function generateDeck() {
            let deck = [];
            for(let i=0; i<=6; i++) {
                for(let j=i; j<=6; j++) {
                    deck.push([i, j]);
                }
            }
            // Embaralhar
            return deck.sort(() => Math.random() - 0.5);
        }

        function processMove(pieceObj, side, playerId) {
            // Verifica se é a vez do jogador
            const currentPlayer = gameState.players[gameState.turnIndex];
            if (currentPlayer.id !== playerId) return;

            // Lógica de validar e inserir no tabuleiro
            let valid = false;
            
            if (gameState.board.length === 0) {
                // Primeira peça
                gameState.board.push({ v1: pieceObj[0], v2: pieceObj[1], rot: 0 }); // rot 0: horizontal
                valid = true;
            } else {
                const head = gameState.board[0];
                const tail = gameState.board[gameState.board.length - 1];
                
                // Lógica simples de ponta: 
                // Board armazena visualmente, mas precisamos saber os valores das pontas abertas
                // Simplificação: vamos recalcular pontas abertas baseadas no histórico
                // Para este exemplo, vou confiar que o cliente enviou o lado certo (left/right) validado
                
                if (side === 'left') {
                    // Inserir no início do array
                    // Precisa verificar match
                    // Lógica visual será calculada no Render
                    gameState.board.unshift({ v1: pieceObj[0], v2: pieceObj[1] });
                    valid = true;
                } else {
                    gameState.board.push({ v1: pieceObj[0], v2: pieceObj[1] });
                    valid = true;
                }
            }

            if (valid) {
                // Remove da mão do jogador
                const playerIndex = gameState.players.findIndex(p => p.id === playerId);
                const p = gameState.players[playerIndex];
                
                // Encontrar e remover peça da mão
                const idx = p.hand.findIndex(h => (h[0]===pieceObj[0] && h[1]===pieceObj[1]));
                if(idx > -1) p.hand.splice(idx, 1);
                p.count = p.hand.length;

                // Verificar vitória
                if (p.count === 0) {
                    gameState.status = 'ended';
                    updateStatus(`VENCEDOR: ${p.name}!`);
                } else {
                    nextTurn();
                }
            }
            
            broadcastState();
        }

        function nextTurn() {
            gameState.turnIndex = (gameState.turnIndex + 1) % gameState.players.length;
            // Verifica se o próximo jogador tem jogada. Se não, passa automaticamente (simplificação)
            // Num jogo real, precisa comprar do monte ou passar explicitamente.
            broadcastState();
        }

        // --- RENDERIZAÇÃO E INTERFACE (CLIENTE) ---

        function startGameUI(room) {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'flex';
            document.getElementById('room-info').innerText = "Sala: (Link copiado)";
            document.getElementById('my-name-display').innerText = myName;
            
            // Ajustar Canvas
            resizeCanvas();
            window.addEventListener('resize', () => {
                resizeCanvas();
                renderBoard();
            });
        }

        function resizeCanvas() {
            // Canvas grande para permitir rolagem
            canvas.width = 2000;
            canvas.height = 2000;
            // Centraliza scroll inicialmente
            const wrapper = document.getElementById('board-wrapper');
            wrapper.scrollLeft = (canvas.width - wrapper.clientWidth) / 2;
            wrapper.scrollTop = (canvas.height - wrapper.clientHeight) / 2;
        }

        function updateInfo() {
            const currentP = gameState.players[gameState.turnIndex];
            if (!currentP) return;
            
            let status = "";
            if (gameState.status === 'playing') {
                status = `Vez de: ${currentP.name}`;
                if (currentP.id === myId) status += " (SUA VEZ)";
            } else if (gameState.status === 'ended') {
                status = "Fim de jogo!";
            } else {
                status = `Aguardando... (${gameState.players.length}/4)`;
            }
            document.getElementById('status-msg').innerText = status;
        }

        // DESENHO DO TABULEIRO (SNAKE LOGIC)
        function renderBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameState.board.length === 0) return;

            // Configuração do "Snake"
            // Começa no centro do canvas
            let cx = canvas.width / 2;
            let cy = canvas.height / 2;
            
            // Vamos redesenhar tudo baseando-se na conexão
            // Precisamos saber qual valor está conectado a qual para desenhar corretamente
            // Para simplificar a visualização neste exemplo, assumiremos uma lógica linear visual
            // Onde as peças se conectam "logicamente".
            
            // Lógica de "Snake":
            // Define limites para dobrar
            const limitRight = cx + 400; 
            const limitLeft = cx - 400;
            
            // Simulação de renderização "Snake"
            // Precisamos rastrear as "pontas" abertas lógicas para saber como a próxima peça se conecta
            // Mas visualmente, vamos iterar da peça 0 até o fim.
            
            // IMPORTANTE: Em um jogo real, precisamos saber EXATAMENTE qual lado da peça [v1, v2]
            // se conectou ao anterior. O servidor (Host) deveria mandar isso processado.
            // Aqui faremos uma heurística visual.
            
            let x = cx;
            let y = cy;
            let dir = 1; // 1 = direita, -1 = esquerda, 2 = baixo, 3 = cima
            let angle = 0; // 0 = horizontal, 90 = vertical
            
            // Desenha a primeira peça
            drawPiece(ctx, gameState.board[0], x, y, 0);
            
            // Calcular posições das próximas
            // Essa lógica precisa ser robusta para detectar "dobras"
            // Para este demo, faremos uma linha simples que dobra
            
            let currentX = x + PIECE_H/2 + 2; 
            let currentY = y;
            let currentDir = 'right'; // right, down-right, left, down-left
            
            for (let i = 1; i < gameState.board.length; i++) {
                const p = gameState.board[i];
                const isDouble = p.v1 === p.v2;
                
                // Verifica limite da tela para dobrar
                if (currentDir === 'right') {
                    if (currentX > limitRight) {
                        // Dobra para baixo
                        currentX += 20; // Ajuste fino
                        currentY += PIECE_H/2 + 20;
                        drawPiece(ctx, p, currentX, currentY, 90); // Peça na curva
                        currentY += PIECE_H/2 + 20;
                        currentX -= 20;
                        currentDir = 'left';
                    } else {
                        // Segue reto
                        currentX += (isDouble ? PIECE_W/2 : PIECE_H/2) + GAP;
                        drawPiece(ctx, p, currentX, currentY, isDouble ? 90 : 0);
                        currentX += (isDouble ? PIECE_W/2 : PIECE_H/2) + GAP;
                    }
                } else if (currentDir === 'left') {
                    if (currentX < limitLeft) {
                        // Dobra para baixo
                        currentX -= 20;
                        currentY += PIECE_H/2 + 20;
                        drawPiece(ctx, p, currentX, currentY, 90);
                        currentY += PIECE_H/2 + 20;
                        currentX += 20;
                        currentDir = 'right';
                    } else {
                         // Segue reto esquerda
                        currentX -= (isDouble ? PIECE_W/2 : PIECE_H/2) + GAP;
                        drawPiece(ctx, p, currentX, currentY, isDouble ? 90 : 0);
                        currentX -= (isDouble ? PIECE_W/2 : PIECE_H/2) + GAP;
                    }
                }
            }
            
            // Nota: Para desenhar a esquerda da peça inicial (unshift), precisaríamos calcular "para trás".
            // No modo simplificado deste código, as peças novas são adicionadas visualmente à direita para demonstração.
        }

        function drawPiece(ctx, piece, x, y, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            
            // Corpo da peça
            ctx.fillStyle = '#fff';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 5;
            ctx.fillRect(-PIECE_H/2, -PIECE_W/2, PIECE_H, PIECE_W);
            
            // Divisória
            ctx.beginPath();
            ctx.moveTo(0, -PIECE_W/2 + 5);
            ctx.lineTo(0, PIECE_W/2 - 5);
            ctx.strokeStyle = '#ccc';
            ctx.stroke();

            // Dots (Valores)
            drawDots(ctx, piece.v1, -PIECE_H/4, 0);
            drawDots(ctx, piece.v2, PIECE_H/4, 0);

            ctx.restore();
        }

        function drawDots(ctx, val, ox, oy) {
            ctx.fillStyle = 'black';
            const s = 4; // size dot
            const d = 10; // distance
            
            // Padrões de dados
            if([1,3,5].includes(val)) ctx.fillRect(ox-s/2, oy-s/2, s, s); // Centro
            if([2,3,4,5,6].includes(val)) {
                ctx.fillRect(ox-d-s/2, oy-d-s/2, s, s); // Top Left
                ctx.fillRect(ox+d-s/2, oy+d-s/2, s, s); // Bottom Right
            }
            if([4,5,6].includes(val)) {
                ctx.fillRect(ox+d-s/2, oy-d-s/2, s, s); // Top Right
                ctx.fillRect(ox-d-s/2, oy+d-s/2, s, s); // Bottom Left
            }
            if(val === 6) {
                ctx.fillRect(ox-d-s/2, oy-s/2, s, s); // Mid Left
                ctx.fillRect(ox+d-s/2, oy-s/2, s, s); // Mid Right
            }
        }

        function renderHand() {
            handDiv.innerHTML = '';
            // Encontra meu player
            const myPlayer = gameState.players.find(p => p.id === myId);
            if (!myPlayer) return;

            myPlayer.hand.forEach(piece => {
                const el = document.createElement('div');
                el.className = 'domino-piece';
                
                // CSS Dots generator helper
                const getDots = (n) => {
                    let html = '<div class="dot-container">';
                    // Map dots basic logic for CSS grid
                    const map = {
                        1: [4], 2: [0,8], 3:[0,4,8], 4:[0,2,6,8], 5:[0,2,4,6,8], 6:[0,2,3,5,6,8], 0:[]
                    };
                    for(let i=0; i<9; i++) {
                        html += map[n].includes(i) ? '<div class="dot"></div>' : '<div></div>';
                    }
                    html += '</div>';
                    return html;
                }

                el.innerHTML = `
                    <div class="half top">${getDots(piece[0])}</div>
                    <div class="half">${getDots(piece[1])}</div>
                `;
                
                // Interação
                el.onclick = () => {
                    if (gameState.turnIndex !== -1 && gameState.players[gameState.turnIndex].id === myId) {
                        attemptPlay(piece);
                    }
                };

                handDiv.appendChild(el);
            });
        }

        function attemptPlay(piece) {
            // Lógica simples: Tenta jogar na direita, se não der, tenta na esquerda
            // Num jogo real, se couber nos dois lados, o usuário deve escolher.
            
            // Precisamos saber as pontas do tabuleiro
            if (gameState.board.length === 0) {
                sendMove(piece, 'right');
                return;
            }
            
            const head = gameState.board[0]; // Esquerda visual (simplificado)
            const tail = gameState.board[gameState.board.length-1]; // Direita visual
            
            // Aqui precisaríamos da lógica real de "Open Ends" (Valores nas pontas)
            // Como o board armazena objetos visuais, vamos assumir que o Host valida
            // Vamos enviar a peça e deixar o Host decidir/validar
            
            // IMPORTANTE: Para este demo funcionar sem lógica complexa de pontas no cliente:
            // Vamos enviar apenas a peça. O Host (processMove) decide onde encaixa.
            // Se encaixar em ambos, padrão Right.
            
            if (isHost) {
                // Host joga localmente
                // Verifica match simples (exemplo)
                processMove(piece, 'right', myId); 
            } else {
                conn.send({ type: 'MOVE', piece: piece, side: 'right' });
            }
        }

        function sendMove(piece, side) {
             if (isHost) {
                processMove(piece, side, myId);
            } else if (conn) {
                conn.send({ type: 'MOVE', piece: piece, side: side });
            }
        }

        // UTILITÁRIOS
        function copyToClipboard(id) {
            const url = `${window.location.href.split('?')[0]}?room=${id}`;
            navigator.clipboard.writeText(url).then(() => {
                alert("Link da sala copiado! Envie para seus amigos.");
            });
        }

        // INICIA
        init();

    </script>
</body>
</html>
